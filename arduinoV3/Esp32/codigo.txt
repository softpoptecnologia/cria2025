#include <WiFi.h>
#include <PubSubClient.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>

// ---------- REDE / MQTT ----------
const char* ssid         = "SoftpopTecnologia1";
const char* password     = "ailsongomes@#$";
const char* mqtt_server  = "192.168.11.104";
const uint16_t mqtt_port = 1883;
const char* device_code  = "esteira1";

// ---------- API ----------
const char* api_host  = "192.168.11.104";
const uint16_t api_port = 5000;
const char* api_path = "/leituras";

// ---------- SENSOR DIGITAL ----------
const int SENSOR_PIN = 17;   // fio preto do E18-D80NK (via divisor 5V->3.3V)
const uint32_t REFRACT_MS = 150;
volatile uint32_t lastTrigger = 0;

// ---------- MOTOR ----------
const int STEP_PIN = 21;
const int DIR_PIN  = 18;
const int EN_PIN   = 05;

const int FULL_STEPS_PER_REV = 200;
const int MICROSTEP = 2;
const int RPM = 50;

// Timer do ESP32
hw_timer_t* motorTimer = NULL;
portMUX_TYPE timerMux = portMUX_INITIALIZER_UNLOCKED;
volatile bool motorEnabled = false;

// ---------- CONTROLE ----------
volatile bool countingEnabled = false;
uint32_t sessao_id = 0;

// ---------- ENVIO EM LOTE ----------
volatile uint32_t bufferCount = 0;
const uint32_t BATCH_SIZE = 10;
const uint32_t BATCH_MS   = 2000;
uint32_t lastSendMs = 0;

// ---------- MQTT ----------
WiFiClient wifiClient;
PubSubClient client(wifiClient);
String topic_cmd;

// ---------- Utils ----------
String apiURL() {
  String url = "http://";
  url += api_host; url += ":"; url += String(api_port); url += api_path;
  return url;
}

bool postBatch(uint32_t inc) {
  if (inc == 0 || sessao_id == 0) return true;
  if (WiFi.status() != WL_CONNECTED) return false;

  HTTPClient http;
  http.begin(apiURL());
  http.addHeader("Content-Type", "application/json");

  StaticJsonDocument<256> doc;
  doc["sessao_id"]   = sessao_id;
  doc["device_code"] = device_code;
  doc["inc"]         = inc;
  doc["ts"]          = "";

  String payload; serializeJson(doc, payload);
  int code = http.POST(payload);
  if (code > 0) {
    String resp = http.getString();
    Serial.printf("[API] POST => %d | %s\n", code, resp.c_str());
  } else {
    Serial.printf("[API] POST falhou: %s\n", http.errorToString(code).c_str());
  }
  http.end();
  return (code >= 200 && code < 300);
}

void flushBufferIfNeeded(bool force = false) {
  uint32_t now = millis();
  static uint32_t localBuffer = 0;

  portENTER_CRITICAL(&timerMux);
  localBuffer = bufferCount;
  if (force) bufferCount = 0;
  portEXIT_CRITICAL(&timerMux);

  if (force || localBuffer >= BATCH_SIZE || (now - lastSendMs) >= BATCH_MS) {
    if (localBuffer > 0) {
      bool ok = postBatch(localBuffer);
      if (ok) {
        portENTER_CRITICAL(&timerMux);
        bufferCount -= localBuffer;
        portEXIT_CRITICAL(&timerMux);
      }
      lastSendMs = now;
    } else {
      lastSendMs = now;
    }
  }
}

// ---------- SENSOR ----------
void IRAM_ATTR sensorISR() {
  uint32_t now = millis();
  if (countingEnabled && (now - lastTrigger > REFRACT_MS)) {
    portENTER_CRITICAL_ISR(&timerMux);
    bufferCount++;
    portEXIT_CRITICAL_ISR(&timerMux);
    lastTrigger = now;
  }
}

// ---------- MOTOR ----------
unsigned int rpmToHalfUs(int rpm) {
  long steps_per_rev = (long)FULL_STEPS_PER_REV * MICROSTEP;
  double freq = (double)rpm * steps_per_rev / 60.0;
  double half_us = 1e6 / (2.0 * freq);
  if (half_us < 3) half_us = 3;
  return (unsigned int)half_us;
}

// Timer ISR do motor
void IRAM_ATTR motorISR() {
  if (!motorEnabled) return;
  digitalWrite(STEP_PIN, !digitalRead(STEP_PIN));
}

void setupMotorTimer() {
  unsigned int half_us = rpmToHalfUs(RPM);

  // Core ESP32 3.x usa nova API
  motorTimer = timerBegin(1000000);          // 1 MHz base clock
  timerAttachInterrupt(motorTimer, &motorISR);
  timerAlarm(motorTimer, half_us, true, 0);  // half_us = tempo entre pulsos
}

void motorStart() {
  digitalWrite(EN_PIN, LOW);   // habilita driver
  digitalWrite(DIR_PIN, LOW);  // sentido fixo
  motorEnabled = true;
  Serial.println(">>> MOTOR LIGADO");
}

void motorStop() {
  motorEnabled = false;
  digitalWrite(EN_PIN, HIGH);  // desabilita driver
  Serial.println(">>> MOTOR DESLIGADO");
}

// ---------- CONTROLE DE SESS√ÉO ----------
void handleStart(uint32_t s_id) {
  sessao_id = s_id;
  countingEnabled = true;
  portENTER_CRITICAL(&timerMux);
  bufferCount = 0;
  portEXIT_CRITICAL(&timerMux);
  lastTrigger = 0;
  lastSendMs = millis();
  motorStart();
  Serial.printf(">>> START sessao_id=%u\n", sessao_id);
}

void handleStop(uint32_t s_id) {
  countingEnabled = false;
  motorStop();
  Serial.printf(">>> STOP sessao_id=%u (flush final)\n", s_id);
  flushBufferIfNeeded(true);
  sessao_id = 0;
}

// ---------- MQTT ----------
void mqttCallback(char* topic, byte* payload, unsigned int length) {
  String msg; msg.reserve(length);
  for (unsigned int i = 0; i < length; i++) msg += (char)payload[i];
  Serial.printf("üì• MQTT %s | %s\n", topic, msg.c_str());

  StaticJsonDocument<256> doc;
  if (deserializeJson(doc, msg)) {
    Serial.println("JSON inv√°lido.");
    return;
  }
  const char* action = doc["action"] | "";
  uint32_t s_id = doc["sessao_id"] | 0;

  if (strcmp(action, "start") == 0 && s_id > 0)      handleStart(s_id);
  else if (strcmp(action, "stop") == 0 && s_id > 0)  handleStop(s_id);
  else Serial.println("Comando desconhecido ou sessao_id ausente.");
}

void mqttReconnect() {
  while (!client.connected()) {
    Serial.print("üîÑ MQTT...");
    String cid = "esp32-" + String(WiFi.macAddress());
    if (client.connect(cid.c_str())) {
      Serial.println("OK");
      client.subscribe(topic_cmd.c_str());
      Serial.printf("üîî Sub: %s\n", topic_cmd.c_str());
    } else {
      Serial.printf("falha rc=%d, tentando em 2s...\n", client.state());
      delay(2000);
    }
  }
}

// ---------- Setup/Loop ----------
void setup() {
  Serial.begin(115200);

  WiFi.begin(ssid, password);
  Serial.print("üåê Conectando");
  while (WiFi.status() != WL_CONNECTED) { Serial.print("."); delay(500); }
  Serial.printf("\nüì∂ Wi-Fi OK: %s\n", WiFi.localIP().toString().c_str());

  // Sensor
  pinMode(SENSOR_PIN, INPUT);
  attachInterrupt(digitalPinToInterrupt(SENSOR_PIN), sensorISR, RISING);

  // Motor
  pinMode(STEP_PIN, OUTPUT);
  pinMode(DIR_PIN, OUTPUT);
  pinMode(EN_PIN, OUTPUT);
  digitalWrite(EN_PIN, HIGH); // come√ßa desligado
  setupMotorTimer();

  // MQTT
  client.setServer(mqtt_server, mqtt_port);
  client.setCallback(mqttCallback);
  topic_cmd = String("factory/default/line/1/device/") + device_code + "/cmd";
}

void loop() {
  if (!client.connected()) mqttReconnect();
  client.loop();

  flushBufferIfNeeded(false);
}
